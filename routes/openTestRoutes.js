const express = require("express");
const router = express.Router();
const path = require("path");
const multer = require("multer");
const OpenTestModel = require("../utils/schema/OpenTests");
const {
  verifyAdminToken,
  verifyUserToken,
  verifyTestToken,
} = require("../utils/middleware/verifyToken");
const TestResultSchema = require("../utils/schema/TestResults");
const jwt = require("jsonwebtoken");

require("dotenv").config();

const storage = multer.diskStorage({
  destination: "./public/uploads/",
  filename: function (req, file, cb) {
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const upload1 = multer({
  storage: storage,
  limits: { fileSize: 1000000 }, // Limit file size to 1MB
  fileFilter: function (req, file, cb) {
    checkFileType(file, cb);
  },
});

function checkFileType(file, cb) {
  // Allowed file extensions
  const filetypes = /pdf/;
  // Check extension
  const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
  // Check mime type
  const mimetype = filetypes.test(file.mimetype);

  if (mimetype && extname) {
    return cb(null, true);
  } else {
    cb("Error: pdfs Only!");
  }
}

router.post(
  "/admin/addopentest",
  verifyAdminToken,
  upload1.none(),
  async (req, res) => {
    var {
      subject,
      chapter,
      standard,
      teacher,
      questions,
      testName,
      startTime,
      endTime,
    } = req.body;
    if (
      (!subject && subject !== "") ||
      (!chapter && chapter !== "") ||
      (!standard && standard !== "") ||
      (!teacher && teacher !== "") ||
      (!questions && questions !== "") ||
      (!testName && testName !== "") ||
      (!startTime && startTime !== "") ||
      (!endTime && endTime !== "")
    ) {
      return res.status(404).json({ error: "all fields are required!" });
    }
    try {
      var isQuestionsValid = true;
      questions = await JSON.parse(questions);
      if (!questions || questions.length === 0) {
        return res
          .status(400)
          .json({ error: "At least one question is needed!" });
      }
      questions.every(({ question, _, answer }) => {
        if (
          typeof question == "string" &&
          (answer === "A" || answer === "B" || answer === "C" || answer === "D")
        ) {
          return true;
        } else {
          isQuestionsValid = false;
          return false;
        }
      });
      if (!isQuestionsValid) {
        return res
          .status(400)
          .json({ error: "Invalid Structure of Questions provided!" });
      }
      var result = await OpenTestModel.findOne({
        subject,
        chapter,
        standard,
        testName,
      });
      if (result) {
        return res
          .status(409)
          .json({ error: "a test with same name already exist!" });
      }
      var result = new OpenTestModel({
        subject,
        chapter,
        standard,
        teacher,
        questions,
        // answers: new Map(
        //   questions.map((question) => [question.id, question.answer])
        // ),
        testName,
        startTime,
        endTime,
      });
      await result.save();
      // var answers = new Map();
      // result.questions.map((element) => {
      //   answers.set(element.id, element.answer);
      // });
      // result.answers = answers;
      // await result.save();
      console.log(result);
      // console.log(result);
      res.json({ success: "test added successfully!" });
    } catch (err) {
      console.log(err);
      res.status(500).json({ error: "error while adding OpenTest!" });
    }
  }
);

router.post(
  "/admin/deleteopentest",
  verifyAdminToken,
  upload1.none(),
  async (req, res) => {
    var { id } = req.body;
    if (!id || id === "") {
      return res.status(422).json({ error: "all fields are required!" });
    }
    try {
      try {
        var result = await OpenTestModel.findOne({
          _id: id,
        });
      } catch (err) {
        return res.status(422).json({ error: "Invalid id for open test!" });
      }
      if (!result) {
        return res
          .status(404)
          .json({ error: "a test with this name doesn't exist!" });
      }
      var result = await OpenTestModel.deleteOne({
        _id: id,
      });
      return res.json({ success: "Test Deleted Successfully!" });
    } catch (err) {
      console.log(err);
      return res.status(500).json({ error: "error while adding OpenTest!" });
    }
  }
);

router.post("/starttest", verifyUserToken, upload1.none(), async (req, res) => {
  try {
    const { testId } = req.body;
    const { email } = req.user;
    if (!testId) {
      return res.status(400).json({ error: "Missing field :testId" });
    }

    var result = await TestResultSchema.findOne({ email });

    if (result?.pendingtest?.testId) {
      return res.status(403).json({
        error: "You can't start another when there's already one test pending!",
        testToken: result.pendingtest.testToken,
        testId: result.pendingtest.testId,
      });
    }
    try {
      await OpenTestModel.findById(testId);
    } catch (err) {
      return res.status(422).json({ error: "Invalid testId" });
    }
    console.log(email);
    var { tests } = await TestResultSchema.findOne({ email });
    tests = tests.filter((element) => element.testId === testId);
    console.log(tests);
    if (tests.length) {
      return res
        .status(422)
        .json({ error: "You've already attempted this test!" });
    }

    var testTokenPayload = { email, testId };
    var testToken = jwt.sign(testTokenPayload, process.env.JWT_SECRET_KEY);
    result.pendingtest = { testId, starttime: Date.now(), testToken };
    await result.save();
    return res.json({ success: "Test Started Successfully", testToken });
  } catch (err) {
    console.log(err);
    res.status(500).json({ error: "Internal Server Error!" });
  }
});

router.post(
  "/fetchtest",
  verifyUserToken,
  verifyTestToken,
  async (req, res) => {
    try {
      if (req.user.email !== req.testToken.email) {
        return res
          .status(401)
          .json({ error: "Invalid combination of user token and testToken!" });
      }
      console.log(req.testToken);
      try {
        var result = await OpenTestModel.findOne(
          {
            _id: req.testToken.testId,
          },
          { "questions.answer": 0 }
        );
        console.log(result);
      } catch (err) {
        console.log(err);
        res.status(422).json({ error: "Invalid test Token!" });
      }
      res.json({ success: "Test fetched successfully!", test: result });
    } catch (err) {
      console.log(err);
      return res.status(500).json({ error: "Internal Server Error!" });
    }
  }
);

router.post(
  "/submittest",
  verifyUserToken,
  verifyTestToken,
  upload1.none(),
  async (req, res) => {
    try {
      if (req.user.email !== req.testToken.email) {
        return res
          .status(401)
          .json({ error: "Invalid combination of user token and testToken!" });
      }
      var { email, testId } = req.testToken;
      var { answers } = req.body;
      if (!answers) {
        return res.status(400).json({ error: "Answers field is required" });
      }
      answers = await JSON.parse(answers);
      if (typeof answers !== "object") {
        return res.status(400).json({ error: "Invalid type of Answers" });
      }

      var { questions } = await OpenTestModel.findById(testId);
      totalMarks = questions.length;

      var obtainedMarks = 0;
      var notAttempted = 0;
      questions.map((element) => {
        console.log(element.id, answers, testId);
        if (!answers[element.id]) {
          notAttempted += 1;
        }
        if (answers[element.id] === element.answer) {
          obtainedMarks += 1;
        }
      });

      const prevTests = await TestResultSchema.findOne({ email });
      var result = prevTests.tests.filter(
        (element) => element.testId === testId
      );
      if (result.length) {
        return res.status(422).json({
          error: "You've already attempted the test!",
          previousResult: {
            obtainedMarks: result[0].obtainedMarks,
            notAttempted: result[0].notAttempted,
            totalMarks: result[0].totalMarks,
          },
        });
      }
      prevTests.tests.push({
        testId,
        obtainedMarks,
        notAttempted,
        totalMarks,
        time: Date.now(),
      });
      await prevTests.save();
      await TestResultSchema.updateOne(
        { email },
        { $unset: { pendingtest: 1 } }
      );

      res.json({
        success: "Test submitted successfully!",
        obtainedMarks,
        notAttempted,
        totalMarks,
      });
    } catch (err) {
      console.log(err);
      return res.status(500).json({ error: "Internal Server Error!" });
    }
  }
);

router.post(
  "/fetchcompletedtests",
  verifyUserToken,
  upload1.none(),
  async (req, res) => {
    try {
      const { email } = req.user;
      const completedTestDetails = await TestResultSchema.aggregate([
        {
          $match: { email },
        },
        {
          $unwind: "$tests",
        },
        {
          $lookup: {
            from: "opentests",
            let: { testId: "$tests.testId" },
            pipeline: [
              {
                $match: {
                  $expr: { $eq: ["$_id", { $toObjectId: "$$testId" }] },
                },
              },
            ],
            as: "testDetails",
          },
        },
        {
          $unwind: "$testDetails",
        },
        {
          $project: {
            "testDetails._id": 1,
            "testDetails.subject": 1,
            "testDetails.chapter": 1,
            "testDetails.standard": 1,
            "testDetails.teacher": 1,
            "testDetails.testName": 1,
            obtainedMarks: "$tests.obtainedMarks",
            notAttempted: "$tests.notAttempted",
            totalMarks: "$tests.totalMarks",
            time: "$tests.time",
          },
        },
      ]);
      res.json({
        success: "Results fetched Successfully",
        results: completedTestDetails,
      });
    } catch (err) {
      console.log(err);
      return res.status(500).json({ error: "Internal Server Error!" });
    }
  }
);
router.post(
  "/fetchalltest",
  verifyUserToken,
  upload1.none(),
  async (req, res) => {
    try {
      var filter = {};
      try {
        Object.entries(req.body).every(([key, value]) => {
          if (
            key === "subject" ||
            key === "chapter" ||
            key === "standard" ||
            key === "testName" ||
            key === "teacher"
          ) {
            filter[key] = value;
            return true;
          } else {
            throw Error("Invalid field received in req body!");
          }
        });
      } catch (err) {
        console.log(err);
        return res
          .status(400)
          .json({ error: "Invalid field provided in req body!" });
      }

      var result = await OpenTestModel.find(filter, {
        standard: 1,
        chapter: 1,
        subject: 1,
        teacher: 1,
        testName: 1,
        _id: 1,
        startTime: 1,
        endTime: 1,
      });
      res.json(result);
    } catch (err) {
      console.log(err);
      return res.status(500).json({ error: "Internal Server Error!" });
    }
  }
);
module.exports = router;
